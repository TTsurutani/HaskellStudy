module Chunk where

onepuls :: Num a b => (a,b) -> Bool

onepuls (x,y)
 | x + 1 == y = True
 | otherwise = False
-- 隣り合う値を評価し、評価値が偽になるところでチャンクを区切る
-- まずチャンクを作成する関数を書き、次にそれをリストの最後まで適用する関数に渡す方針とする
-- chunkWhile	
-- | 1ずつ増加する部分配列ごとに分ける。
-- >>> chunkWhile 1pulus [1,2,4,9,10,11,12,15,16,19,20,21]
-- [[1,2],[4],[9,10,11,12],[15,16],[19,20,21]]
-- | １ずつ増加したら真になる関数
-- >>> 1pulus [1,2]
-- True
-- >>> 1pulus [2,4]
-- False

-- | 条件が偽になるところでチャンクを作る関数
-- >>> chunk 1plus [1,2,4,9,10,11,12,15,16,19,20,21]
-- [1,2]
-- >>> chunk 1pulus [9,10,11,12,15,16,19,20,21]
-- [9,10,11,12]
-- | 条件にマッチするリストを簡約する
-- >>> fromatFromTo [9,10,11,12]
-- "9-12"
-- >>> fromatFromTo [1,2]
-- ["1","2"]
-- | つなぐ
-- >>> joit2Char ls
-- "1,2,4,9-12,15,16,19-21"

{--
# 増加のみの部分配列ごとに分ける。
a = [0,9,2,2,3,2,7,5,9,5]
p a.chunk_while {|i, j| i <= j }.to_a
# => [[0,9], [2,2,3], [2,7], [5,9], [5]]

# 隣り合う偶数同士、奇数同士の部分配列ごとに分ける。
# (Enumerable#chunk を使って実現する事も可能)
a = [7,5,9,2,0,7,9,4,2,0]
p a.chunk_while {|i, j| i.even? == j.even? }.to_a
# => [[7,5,9],[2,0],[7,9],[4,2,0]]
--}